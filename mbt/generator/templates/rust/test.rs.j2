// Code generated by fizzbee-mbt generator; DO NOT EDIT.

// Import the generated traits, adapters, and framework utilities
use super::traits::*;
use super::adapters::{new_{{ model_base_name }}_model, get_test_options};

use fizzbee_mbt::traits::*;
use fizzbee_mbt::types::*;
use fizzbee_mbt::value::*;
use fizzbee_mbt::error::MbtError;
use async_trait::async_trait;

/// The Dispatcher routes actions from the MBT framework to the correct Role/Model instance.
/// It wraps the concrete Model implementation.
pub struct {{ model_name }}ActionDispatcher<T>
where
    T: {{ model_name }}Model + Send + Sync + 'static,
{
    // The concrete model instance is owned directly
    model: Option<T>,
}

#[async_trait]
impl<T> Model for {{ model_name }}ActionDispatcher<T>
where
    T: Model + {{ model_name }}Model + Send + Sync + 'static,
{
    /// Delegates initialization to the inner model instance.
    async fn init(&mut self) -> Result<(), MbtError> {
        self.model.as_mut().ok_or_else(|| MbtError::other("Model not found"))?
            .init().await
    }

    /// Delegates cleanup to the inner model instance.
    async fn cleanup(&mut self) -> Result<(), MbtError> {
        self.model.as_mut().ok_or_else(|| MbtError::other("Model not found"))?
            .cleanup().await
    }
}

impl<T> {{ model_name }}ActionDispatcher<T>
where
    T: {{ model_name }}Model + Send + Sync + 'static,
{
    pub fn new(model: T) -> Self {
        {{ model_name }}ActionDispatcher {
            model: Some(model),
        }
    }
}

/// Implementation of the framework's core execution contract (`DispatchModel`).
#[async_trait]
impl<T> DispatchModel for {{ model_name }}ActionDispatcher<T>
where
    T: {{ model_name }}Model,
    T: Send + Sync + 'static,
{
    async fn execute(
        &self,
        role_id: &RoleId,
        function_name: &str,
        args: &[Arg],
    ) -> Result<Value, MbtError> {

        let inner_model_ref = self.model.as_ref().ok_or_else(|| {
            MbtError::other("Model is not initialized or has been moved out of the dispatcher.")
        })?;

        match role_id.role_name.as_str() {
            // Role actions
            {% for role in file.roles %}
            "{{ role.name }}" => {
                let index = role_id.index as usize;
                
                let roles_vec = inner_model_ref.get_{{ role.name|lower }}_roles()?;
                
                let role_rc = roles_vec.get(index)
                    .ok_or(MbtError::other(format!("{}Role instance not found at index {}", "{{ role.name }}", index)))?;

                match function_name {
                    {% for action in role.actions -%}
                    {% if action.name != "Init" %}
                    "{{ action.name }}" => role_rc.action_{{ action.name|lower }}(args).await,
                    {%- endif %}
                    {%- endfor %}
                    _ => Err(MbtError::other(
                        format!("Unknown action '{}' for {{ role.name }}Role", function_name)
                    )),
                }
            }
            {% endfor %}
            
            // Top-level actions (role_id.role_name is expected to be empty for top-level)
            "" => {
                match function_name {
                    {% for action in file.actions -%}
                    {% if action.name != "Init" %}
                    "{{ action.name }}" => inner_model_ref.action_{{ action.name|lower }}(args).await,
                    {%- endif %}
                    {%- endfor %}
                    _ => Err(MbtError::other(
                        format!("Unknown top-level action: '{}'", function_name)
                    )),
                }
            }

            _ => Err(MbtError::other(format!("Unknown role: {}", role_id.role_name))),
        }
    }
    
    fn get_roles(&self) -> Result<Vec<RoleId>, MbtError> {
        let inner_model_ref = self.model.as_ref().ok_or_else(|| {
            MbtError::other("Model is not initialized or has been moved out of the dispatcher.")
        })?;
        
        let mut all_role_ids = Vec::new();

        // Collect all role IDs
        {% for role in file.roles %}
        {
            let roles = inner_model_ref.get_{{ role.name|lower }}_roles()?;
            let role_ids: Vec<RoleId> = roles.iter()
                .enumerate()
                .map(|(index, _)| RoleId {
                    role_name: "{{ role.name }}".to_string(), 
                    index: index as i32,
                })
                .collect();
            all_role_ids.extend(role_ids);
        }
        {% endfor %}
        
        Ok(all_role_ids)
    }
}

// Use a runtime test macro to allow async operations inside the test function
#[test]
fn test_{{ model_base_name }}_model() -> Result<(), MbtError> {
    let model = new_{{ model_base_name }}_model(); 
    
    let dispatcher = {{ model_name }}ActionDispatcher::new(model); 
    
    // Executes model-based test traces.
    fizzbee_mbt::run_mbt_test(dispatcher, get_test_options())?;
    
    Ok(())
}